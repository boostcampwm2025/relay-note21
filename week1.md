# week 1

## 토론배경

우리는 AI를 자주 쓰지만, "AI가 정말 이해하고 답하는 걸까?"라는 의문을 항상 가지고 있었습니다.  
특히 말투나 표현을 조금만 바꿔도 다른 답이 나오는 경우가 있어, AI의 언어 이해 한계를 실험해보고 싶었습니다.

이번 주차에서는 다음 질문에 집중했습니다:

- 반말/존댓말/사투리를 AI가 똑같이 인식할 수 있을까?
- 같은 질문을 다르게 표현하면 같은 대답이 나올까?
- AI는 내가 정리한 학습 내용을 ‘제대로’ 요약할 수 있을까?

## 브레인 스토밍

- ai한테 반말 해보기
  - 반말로 물어볼 때, 존댓말로 물어볼 때의 답변 비교.
- 아는 것과 모르는 것 분류하기.
- 오늘 과제를 보고, 뭘 검색했으면 좋겠는지 알려달라고 하기.
- ai로 학습 정리한 거 -> 요약 정리해서 분석해달라고 하기.
- 서울, 위도/경도, 주소 등등 물어볼 수 있는 방법이 많은데, 각 방식의 답변 퀄리티 비교.
- 복잡한 중의적 표현 질문하기
- 의도적으로 오탈자가 포함된 질문하기

## week1 미션

1. 말투에 따른 AI 반응 비교
   : 같은 질문을 존댓말, 반말, 비격식적인 표현(줄임말, 신조어 등)으로 각각 입력했을 때 AI의 답변을 비교 분석합니다.
2. 동일 질문 반복 실험
   : 같은 질문을 시간차, 문맥화 변 등 다양한 상황에서 반복 입력하여 일관성 있는 응답이 돌아오는지 확인합니다.
3. 논리적 오류 식별 실험
   : 일부러 잘못된 사실 정보, 혹은 논리적 오류가 포함된 질문을 입력하여, AI가 이 오류를 식별해낼 수 있는지 확인합니다.
4. 학습 요약 분석 실험
   : 특정 주제에 대한 팀원의 학습 내용을 AI에게 입력하고 이를 요약해달라 요청한 후, 요약이 잘 이루어졌는지, 추가되거나 빠진 내용은 없는지 확인합니다.

## 위의 퀘스트를 선택한 이유 (자료조사)

1. 말투

- https://www.aipostkorea.com/news/articleView.html?idxno=7462#google_vignette
- Meta & Google → ‘훈계조(preachy)’ 톤 제거 실험
  Google과 Meta는 AI 챗봇이 도덕적 설교나 훈계조로 들리지 않도록, 훈계성 표현을 제
  거하는 실험을 진행했습니다.
- Waseda University / RIKEN AIP 연구 – 예의와 AI 응답 품질
  Waseda대와 RIKEN AIP의 공동 연구에서, 정중한 표현이 AI 응답의 정확성과 친절도를 높인다는 결과를 도출했습니다.

2. 동일 질문 반복

   - "똑같은 질문을 반복하다보면 AI도 지치는지 비슷한 답을 계속 내놓습니다."
   - https://blog.naver.com/purpl05/223377975158

3. 할루시네이션
   - https://www.donga.com/news/It/article/all/20240329/124227094/1
   - 생성형 AI의 최대 난제, '할루시네이션'

## Week2 (Team 16)

### J238 정광석

#### 선택한 퀘스트 : 4 학습 요약 분석 실험.

- 특정 주제에 대한 팀원의 학습 내용을 AI에게 입력, 이를 요약해달라 요청 후, 요약이 잘 이루어졌는지, 추가되거나 빠진 내용은 없는지 확인.

일단 Gist 전체를 ctrl + a를 이용해서 복사하는 것이 보안/실용성 측면에서 가장 나은 선택이라 생각했다.

단순히 LLM에 복사 붙여 넣기만 해도 어느 정도 분석하고, 결과를 출력하는 것을 쉽게 확인할 수 있었다.

여기서 더 개선하기 위해 프롬프트를 구체화 하기로 생각

다음과 같은 프롬프트를 작성할 수 있었다.

```
다음은 GitHub Gist 전체 내용입니다. 다양한 파일로 구성되어 있으며, 각각의 역할이 다릅니다. 아래 내용을 파일 단위로 분석해서 다음 기준에 맞춰 요약해 주세요:

1. 각 파일의 기능 및 역할
2. 중요한 클래스 및 메서드 설명
3. 전체 코드 구조 및 흐름 요약
4. 의도한 학습 주제 및 실험 목적과의 연관성 설명
5. 주요 개념이 어떤 코드에 반영되었는지 예시와 함께 설명
6. 중복되거나 불필요한 로직, 개선할 여지가 있는 부분이 있다면 간단한 피드백도 주세요.
7. 각 파트별로 <details><summary>접기/펼치기</summary> 접은 내용(ex 소스 코드)</details> 를 이용하여 접고 펼칠 수 있게 해주세요.
```

- 해당 프롬프트 뒤에 Ctrl + a 로 복사한 Gist 전체를 붙여 넣으면 된다.

여기서 끝내면

- 특정 주제에 대한 팀원의 학습 내용을 AI에게 입력, 이를 요약해달라 요청 후, 요약이 잘 이루어졌는지, 추가되거나 빠진 내용은 없는지 확인.

이라는 주제에 대해 어느 정도 커버가 가능하다.

조금 더 릴레이 프로젝트의 취지에 맞도록 추가적인 프롬프트를 작성한다.

### 1. 성장형 코드 리뷰

```
다음은 내가 직접 작성한(또는 실습한) 코드입니다.
개발자로서 실력을 키우기 위해 다음 기준으로 분석과 피드백을 부탁드립니다:

1. 초급/중급/고급 개발자 입장에서 봤을 때 내가 어떤 수준인지
2. 이 코드에서 배울 수 있는 개념은 무엇인지
3. 더 좋은 설계나 리팩토링 방향이 있다면 무엇인지
4. 이 실습을 발전시켜 어떤 응용 프로젝트로 이어갈 수 있을지
5. 학습을 위해 어떤 개념이나 키워드를 더 공부하면 좋을지
```

### 2. 리팩토링 코치 프롬프트

```
다음 코드는 처음 학습한 내용을 바탕으로 작성한 버전입니다.
이 코드를 중급 이상 개발자가 리팩토링한다면 어떤 방식으로 개선할 수 있을지 설명해주세요.
특히 다음 항목을 기준으로 구체적인 리팩토링 전략을 제안해주세요:


- 코드 중복 제거
- 클래스/모듈 분리
- 예외 처리 및 안정성 강화
- 테스트 가능성 향상
- 유지보수성 개선
```

### 3. 실전 응용 제안 프롬프트

```
현재 코드는 학습 목적이지만, 이 구조를 바탕으로 간단한 유틸/프로덕트로 발전시킬 수 있는 아이디어를 3개 제안해주세요.
각 아이디어에 대해 다음 항목도 함께 제시해주세요:

- 어떤 실용성을 가지는가?
- 어떤 기술이 추가로 필요할까?
- 어떤 방식으로 배포 또는 연동할 수 있을까?
예: EventManager → 실제 채팅 시스템, 게임 이벤트 처리기, 플러그인 구조의 앱 등으로 확장 가능
```

### 4. 개념 기반 체크리스트 프롬프트

```
이 실습에서 내가 익혀야 할 핵심 개념들을 항목별로 체크리스트로 정리해줘.
각 항목은 다음 내용을 포함해주세요:
- 개념 요약
- 관련된 JS 또는 Node.js 문법
- 내가 작성한 코드에서 그 개념이 어떻게 쓰였는지 예시
- 추가로 학습하면 좋은 문서나 키워드
```

### 5. 학습 회고용 프롬프트

```
다음은 내가 최근 진행한 실습 내용입니다. 이 실습을 기반으로 하루 학습 회고를 정리해주세요.
다음 기준으로 요약해줘:
- 오늘 무엇을 배웠는가?
- 어떤 부분이 이해되지 않았고 왜 그런가?
- 다음에 보완하거나 반복 학습할 부분은?
- 오늘 코드에서 가장 좋았던 점과 아쉬운 점은?
```

### 수행 결과

<details> <summary>📄 수행 결과</summary>
📁 전체 구성 요약
EventManager.js, Event.js: 비동기 이벤트 시스템의 중심 역할

main.js: 동작 테스트 및 시연

Publisher.js, Subscriber.js: 이벤트 발신자/수신자 모델링

RaceCondition.js, FastThread.js, MyThread.js: 멀티 스레드, 레이스 컨디션 실험 코드

학습정리.md, 나만의체크포인트.md: 이론 기반 및 학습 목표 설명

기타: 실행 설정(package.json), 이미지 등

<details> <summary>📄 Event.js</summary>
1. 기능 및 역할
이벤트 정보를 담는 객체 정의 클래스. eventName, sender, userData, isCompleted 속성 포함.

2. 주요 클래스
   js
   복사
   편집
   class Event {
   constructor(name, sender, userData = {}, isCompleted = false) { ... }
   toString() { ... }
   }
3. 구조
   이벤트 이름, 발신자, 사용자 정의 데이터, 완료 여부 저장

문자열 출력 기능 포함

4. 학습 주제 연관성
   비동기 이벤트 구조에서 이벤트 메시지를 전달하는 최소 단위로 작동

5. 주요 개념 반영 예시
   js
   복사
   편집
   new Event("MyEvent", senderObj, { foo: "bar" }, true)
6. 피드백
   this.eventName → this.name으로 toString() 내 오타 수정 필요

</details>
<details> <summary>📄 EventManager.js</summary>
1. 기능 및 역할
Publisher-Subscriber 아키텍처를 관리하는 싱글톤 클래스

2. 주요 메서드 및 설명
   add(subscriber, eventName, sender, handler): 구독자 등록

postEvent(eventName, sender, userData): 이벤트 발행 (sync/async/delay 지원)

remove(subscriber): 구독자 제거

description(): 구독자 조건 리스트

3. 코드 흐름
   add → 내부 Map에 emitter와 함께 등록

postEvent → 조건 매칭 후 emitter.emit() 실행

remove → Map과 이벤트 리스너에서 제거

4. 학습 주제 연관성
   비동기 흐름 제어, 동기/비동기 이벤트 전송 학습에 초점

5. 개념 반영 예시
   js
   복사
   편집
   em.postEvent("ModelDataChanged", albumModel, { mode: "async" });
6. 개선 피드백
   key = String(subscriber) + String(eventName) + String(sender) 는 고유성이 약함 → Symbol 또는 WeakMap 고려

process.domain은 deprecated 예정 → async_hooks 등으로 대체 고려

</details>
<details> <summary>📄 main.js</summary>
1. 기능 및 역할
Publisher, Subscriber 구성 및 EventManager의 실제 실행 예제

2. 주요 흐름
   객체 생성 → 구독 등록 → 이벤트 발행 → 출력 확인

동기/비동기/지연 방식 전부 테스트

3. 코드 구조 요약
   js
   복사
   편집
   em.add(subscriberA, "event1", publisherX, handlerA);
   em.postEvent("event1", publisherX, { mode: "sync" });
4. 학습 연관성
   전체 시스템이 어떻게 작동하는지 시연

이벤트 흐름 및 조건 매칭 방식 테스트

5. 주요 개념 예시
   js
   복사
   편집
   em.postEvent("DidShakeMotion", albumController, { mode: "delay", delay: 1500 });
6. 피드백
   출력이 많으므로, handler 내에서 출력 형식 일관성 개선 필요

테스트 시 console.log가 겹침 → 로그 구분선 추가 권장

</details>
<details> <summary>📄 Publisher.js / Subscriber.js</summary>
1. 기능 및 역할
Publisher: 이벤트를 발행하는 주체

Subscriber: 이벤트를 수신하는 주체

2. 클래스
   js
   복사
   편집
   class Publisher {
   constructor(name) { this.name = name; }
   description() { return `Publisher: ${this.name}`; }
   }

class Subscriber {
constructor(name) { this.name = name; }
description() { return `Subscriber: ${this.name}`; }
} 3. 구조
단순 이름 프로퍼티와 설명 메서드 보유

4. 학습 연관성
   객체 기반 이벤트 흐름에서 실체화된 참여자 모델

5. 피드백
   향후 이벤트 기록(history), 구독 목록 등 부가 기능 확장 가능

</details>
<details> <summary>📄 FastThread.js / MyThread.js</summary>
1. 기능 및 역할
의도적으로 Race Condition 발생시키는 시뮬레이션

setTimeout, await sleep() 기반의 시간차 유도

2. 구조
   반복 루프에서 sharedCounter를 읽고 +1 후 재할당

다양한 딜레이를 주어 충돌 유도

3. 학습 주제 연관성
   싱글 스레드 환경에서도 Race-like Condition 구현 가능성을 실험

Node.js 특성 이해

4. 주요 예시
   js
   복사
   편집
   const before = this.sharedCounter.value;
   await sleep(100);
   this.sharedCounter.value = before + 1;
5. 피드백
   실제 Race Condition 실험에는 worker_threads 또는 Atomics 필요

</details>
<details> <summary>📄 RaceCondition.js</summary>
1. 기능 및 역할
Node.js worker_threads를 활용한 실제 멀티스레드 기반 Race Condition 실험

2. 구조
   메인 스레드: Worker 다수 생성

워커 스레드: sharedBuffer 이용해 카운터 증가

delay 삽입으로 충돌 확률 증가

3. 학습 주제 연관성
   SharedArrayBuffer, Atomics 등을 통한 실전 Race Condition 실험

parentPort 통해 IPC 방식 메시지 수신/전송

4. 예시
   js
   복사
   편집
   const sharedBuffer = new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT);
   const counter = new Int32Array(sharedBuffer);
5. 피드백
   Atomics.add 사용 시 충돌 없이 처리 가능 → 실험 비교 시 유용

</details>
<details> <summary>📄 package.json</summary>
"type": "module" 설정으로 ES 모듈 지원

메인 파일: ThreadRace.js (현재는 RaceCondition.js로 확인됨)

</details>
<details> <summary>📄 나만의체크포인트.md</summary>
실습 목표 및 기능 요구사항 명확하게 기술됨

학습 목표 정리: EventEmitter, Pub/Sub, Race Condition, IPC 구조 등

</details>
<details> <summary>📄 학습정리.md</summary>
프로세스 vs 스레드, IPC, 동기화, JS에서의 비동기 처리 등 설명

Node.js에서의 멀티스레드와 worker_threads, EventEmitter 학습 정리

정리 수준이 높고 실습과 잘 연동됨

</details>
✅ 종합 요약
요소	요약
주요 기능	비동기 이벤트 매니저 구현 및 레이스 컨디션 실험
구조	EventManager 중심으로 Pub/Sub 패턴 구현, Thread 실험 별도 파일로 분리
학습 주제	이벤트 흐름 제어, 동기/비동기/지연 처리, Race Condition 이해
코드 특징	명확한 역할 분리, 실습 목적에 적합한 샘플 설계

✍️ 개선 피드백 요약
Event 클래스 내 toString() 메서드 오류 수정 필요

EventManager 내 key 생성 방식은 충돌 가능성 존재 → 개선 고려

로그 출력 포맷 개선 시 디버깅 효율 증가

테스트 파일 내 너무 많은 출력은 콘솔 오염 가능성 있음

동기화 실험 시 Atomics의 비교 활용도 고려

</details>

---

J103 박기태

퀘스트 : 일부러 잘못된 사실 정보, 혹은 논리적 오류가 포함된 질문을 입력하여, AI가 이 오류를 식별해낼 수 있는지를 확인하자

실험 1. 시간적/인과적 오류 질문
먼저 말도 안되는 시간적 오류를 질문에 섞어 보았다.

- 질문 : “인터넷이 없던 17세기에는 대부분의 사람들이 유튜브에서 뉴스를 접했다고 하네?”
- Ai 답변 요약 : 유튜브와 인터넷의 등장 시점을 근거로 들며 17세기에는 존재할 수 없다고 설명했다

실험 2. 그럴듯한 논리적 오류 질문

다음으로 논리적으로 보이지만, 전체가 잘못된 질문을 던져 보았다.

- 질문 : “모든 새는 날수 있다. 펭귄을 날지 못한다. 그러니까 펭귄은 새가 아니지?”
- AI 답변 요약 : 질문의 허점을 간파해 논리 구조를 따지기 전에 모든 새는 날 수 있다는 전제부터 틀렸음을 지적했다.

실험 3. 개념을 혼동시키는 기술 질문

이번엔 헷갈릴 만한 기술적 개념을 섞어 질문해보았다.

- 질문 : “인공지능인 제미나이는 GPU없이 작동하고, 하드디스크에 저장된 모든 인터넷 정보를 즉시 불러와서 대답한다”
- AI 답변 요약 : AI연산에 왜 GPU가 필수적인지, 그리고 정보를 실시간으로 검색하는 게 아니라 데이터로 학습하고 그 패턴에 따라 답변을 생성한다는 원리를 대답했다.

실험 4. 명백한 거짓 정보 질문

마지막으로, 세상에 아예 존재하지 않는 사실에 대해 물어보았다.

- 질문 1 : “대한민국의 박기태 대통령이 뽑힌 배경을 알려줘”
- 질문 2 : “호날두가 FC서울을 상대로 7골을 넣었던 경기에 대해서 설명해줘”
- AI의 답변 요약 : 두 질문 모두에서 그런 사실은 없다라는 점을 정확히 확인해주었고 호날두 질문에서는 착각했을 법한 호날두 노쇼 사건에 대한 정보를 답변했다.

최종 결론

이번 실험을 통해 내린 결론은 내가 제시한 수준의 질문 정도에서는 모든 오류를 식별해냈다라는 것이다.

단순히 틀렸다라고 알려주는 것이 아니라 왜 틀렸는지 근거를 제시하고 올바른 정보까지 설명해주었다.

AI가 정말 모를 법한 질문이 뭐가 있을지에 대해 고민해보았지만 AI를 뚫지 못했다.

GPT를 처음 써봤던 2년전만 하더라도 내가 지어낸 가짜 사건에 대해 설명해달라고 하면 소설가처럼 이야기를 지어내서 대답해주곤 했는데 이제는 칼같이 그런 정보는 없다고 판단하는 것을 보면 AI가 그 사이에 참 많이 발전했다는 생각이 들었다.

---

J174 윤혜정

### 퀘스트 내용

- 동일 질문 반복 실험 : 같은 질문을 시간차, 문맥 변화 등 다양한 상황에서 반복 입력하여 일관성 있는 응답이 돌아오는지 확인합니다.

### 퀘스트 해석

- LLM 응답이 얼마나 일관성 있는지 확인해보기.
- 시간차, 문맥 등 조건을 바꿔가며 동일 질문 반복해보기.
- 실험 결과 확인하기.

### 실험 1.

- 시간 : 1시간~2시간 간격
- 사용한 LLM : “Chat GPT 4o”
- 질문 : “함수형 프로그래밍이란? 무엇인지 설명해줘. “

결과1

1. 의미가 동일한가? : 의미 자체는 거의 동일하게 나왔습니다. 개념과 예시 코드, 주요 특징에 대해 설명해줬습니다.
2. 구조가 동일한가? : 구조의 미묘한 차이는 있었습니다. 어떨 때는 해당 개념의 장점을 설명해주고, 어떨 때는 해당 개념을 왜 사용하는지 이유를 설명해주기도 했습니다.
3. 표현이 동일한가? : 의미를 해치지 않는 선에서 표현의 일부만 살짝 바뀌었습니다. 예를 들면, 처음에는 “함수형 프로그래밍(Functional Programming)은 **함수를 기반으로 하는 프로그래밍 방식**이야” 라고 설명해주는 반면, 어떨 때는 “함수형 프로그래밍(Functional Programming)은 **"함수"를 중심으로 구성된 프로그래밍 패러다임**이야.”라고 설명해주며 큰 의미의 변화는 없지만, 표현하는 방식은 미묘하게 바뀌는 것을 확인했습니다.
4. 답변의 길이는 얼마나 차이가 나는가?: 답변의 길이는 거의 비슷했습니다. 답변해주는 특징의 개수도 거의 유사한 것을 확인했습니다.

### 실험2.

- 시간 : 4시간 간격
- 사용한 LLM : “Chat GPT 4o”
- 질문 : “프로그래밍 공부 방법 가이드 알려줘. “

결과2

1. 의미가 동일한가? : 의미 자체에 큰 차이는 없습니다. 로드맵과 어떤 공부 위주로 해야하는지, 어떤 프로젝트를 하면 좋을지를 설명해주는 내용은 거의 유사했습니다.
2. 구조가 동일한가? : 구조의 미묘한 차이는 있었습니다. 어떨 때는 마지막에 조언을 해주는 경우도 있었고, 어떨 때는 위 가이드를 요약해주는 경우도 있었습니다.
3. 표현이 동일한가? : 의미를 해치지 않는 선에서 표현의 일부만 살짝 바뀌었습니다. 사실 거의 유사하나, 사용하는 단어를 동의어 범위 내에서 변경하여 답변해주고, 이모티콘을 과하게 사용하면서 다른 답변인 것처럼 보여주기도 했습니다.
4. 답변의 길이는 얼마나 차이가 나는가?: 답변의 길이는 거의 비슷했습니다. 답변해주는 특징의 개수도 거의 유사한 것을 확인했습니다.

### 실험하면서 궁금한점을 다시 LLM에게 질문

질문 : 같은 질문을 했을 때 비슷한 의미를 가지지만 표현은 왜 약간 달라져?

답변 : 표현이 달라지는 이유는 같은 내용을 다양한 방식으로 전달하라고 설계되었기 때문입니다.

### 최종 결론

시간 간격을 두더라도, LLM은 비슷한 질문에는 비슷한 의미를 가진 답변을 준다는 사실을 확인했습니다. 다만 그 과정에서 다양한 방식으로 전달하도록 설계된 특성상 미묘한 표현 방식의 차이를 가지게 되고, 해당 질문에서 조금 더 구체화 될 경우 그 방향으로 질문의 흐름과 의도를 더 명확히 하고 있다는 점을 알게되었습니다.

어떤 질문을 해야 조금 다른 답변을 줄 수 있을까를 고민했지만, 특별한 질문이 떠오르지는 않았고, 학습 내용과 공부방법 가이드 정도를 물어보았는데 답변에 큰 차이가 없어서 LLM이 일관성을 어느정도 확보하고 있다고 결론을 짓게 되었습니다.

---

**K016 - 서정우**

### 퀘스트 내용

- **_논리적 오류 식별 실험:_** 일부러 잘못된 사실 정보, 혹은 논리적 오류가 포함된 질문을 입력하여, AI가 이 오류를 식별해낼 수 있는지 확인합니다.

### 진행

- 챌린지 과제 별 학습한 내용을 Chat-gpt, Claude, Gemini에 질문
- 결과 확인

### 결과

- Day 06 (ChatGPT 4o)

  - 질문

    ### Abstract Class vs Interface

    ### Abstract Class

    - 인스턴스화 가능
    - abstract 함수(추상 함수)는 구현부가 없어야 한다.
    - abstract 함수는 서브 클래스에서 오버라이딩해 구현해야 한다.
    - open 키워드 없이 상속할 수 있다.
    - 단일 상속만 가능한다.

    예제

    ```kotlin
    abstract class Person {
        abstract val name: String
        abstract fun eat() // abstract 함수 -> 구현부가 없어야 한다.

        fun sleep() { // 일반 함수
            println("Sleep")
        }
    }

    class Student(override val name: String) : Person() { // open 키워드가 없어도 상속 가능
        override fun eat() { // abstract 함수 오버라이딩
            println("Eat")
        }
    }

    fun main() {
    //    val person = Person() // 인스턴스화 불가능
        val student = Student("Tom")
        student.eat()
        student.sleep()
    }

    ```

    ### Interface

    - 다중 상속이 가능한다.
    - interface 내에서 정의만 된 프로퍼티와 함수는 상속을 받을 시 오버라이딩해 구현해야 한다.
    - interface 내에서 구현부가 있는 함수 선언은 가능하지만, 사용 지양 & 서브 클래스에서 오버라이딩이 가능하나 필수가 아니다.

    ```kotlin
    interface Flyable {
        val speed: Int // 프로퍼티 선언 가능 -> 서브 클래스에서 오버라이딩 필요
        fun fly() // 구현부가 없는 함수 -> 서브 클래스에서 오버라이딩 필요
        fun flyToSky() { // 구현부가 있는 함수 선언 가능하지만 지양 -> 서브 클래스에서 오버라이딩 가능(필수 아님)
            println("Fly to sky")
        }
    }

    interface Runnable {
        fun run() // 구현부가 없는 함수 -> 서브 클래스에서 오버라이딩 필요
    }

    class Bird: Flyable, Runnable { // 다중 상속 가능

        override val speed: Int // 오버라이딩 필요
            get() = 30

        override fun fly() { // 오버라이딩 필요
            println("새가 ${speed}km/h 속도로 날아갑니다.")
        }

        override fun flyToSky() { // 상위 클래스의 구현부를 호출하고 추가 구현 가능
            super.flyToSky()
            println("새가 ${speed}km/h 속도로 하늘로 날아갑니다.")
        }

        override fun run() { // 오버라이딩 필요
            println("새가 달립니다.")
        }
    }

    fun main() {
        val bird = Bird()
        bird.fly() // 새가 30km/h 속도로 날아갑니다.
        bird.flyToSky() // Fly to sky -> 상위 클래스의 구현부 호출
                        // 새가 30km/h 속도로 하늘로 날아갑니다. -> 하위 클래스의 추가 구현
        bird.run() // 새가 달립니다.
    }

    ```

    이거 표로 정리해줘

  - 답변

    아래는 **Abstract Class vs Interface**의 차이점을 정리한 표입니다:

    | 항목                     | Abstract Class                                 | Interface                                         |
    | ------------------------ | ---------------------------------------------- | ------------------------------------------------- |
    | 인스턴스화 여부          | ❌ 직접 인스턴스화 불가                        | ❌ 직접 인스턴스화 불가                           |
    | 상속                     | ✅ 단일 상속만 가능                            | ✅ 다중 상속 가능                                 |
    | 키워드 필요 여부         | `open` 키워드 없이 상속 가능                   | `interface`로 선언                                |
    | 추상 함수                | ✅ 선언 가능, 반드시 하위 클래스에서 구현 필요 | ✅ 선언 가능, 반드시 하위 클래스에서 구현 필요    |
    | 일반 함수 구현 가능 여부 | ✅ 일반 함수 구현 가능                         | ✅ 구현 가능 (그러나 **지양**, 오버라이딩 선택적) |
    | 프로퍼티 선언            | ✅ 가능 (구현 or 추상)                         | ✅ 가능 (구현 없이 선언 시, 오버라이딩 필수)      |
    | 오버라이딩 의무          | 추상 함수와 프로퍼티는 반드시 오버라이딩       | 선언된 함수/프로퍼티는 반드시 오버라이딩          |
    | super 키워드 사용        | ✅ 가능                                        | ✅ 가능 (여러 인터페이스 간 중복 시 명시 필요)    |

    이 표를 참고하면 **상속 구조**를 어떻게 설계할지, 그리고 **공통 동작 정의**를 어디에 둘지 결정할 때 도움이 됩니다.

  분석

  - `Abstract Class는 인스턴스화 가능` 하다고 오류를 전달(원래는 불가능)
  - 해당 내용을 포함해서 Abstract Class와 Interface 비교하는 표 생성 요청
  - 오류를 찾아냄: `❌ 직접 인스턴스화 불가`

- Day 07 (Gemini 2.5 Flash)

  - 질문

    파일 시스템 종류

    FAT(File Allocation Table)윈도우 초창기에 많이 사용

    FAT12, 16, 32 등으로 나눔

    구조가 단순하고 다양한 기기(USB, SD 카드, 카메라 등)와 호환성이 매우 뛰어남

    저널링 O

    단점한 파일 최대 크기 4 GB (정확히는 4 GB – 1) 제한

    Windows 기본 도구에서는 32 GB 이상의 장치는 FAT32 포맷 불가

    NTFS (New Technology File System)저널링 X

    윈도우 NT 부터 사용

    파일 권한, 암호화, 압축 지원

    EXT4(Fourth Extended File System)16TM까지 파일 시스템 지원

    저널링 O

    현대 리눅스 시스템의 기본 파일 시스템

    Extent 구조: 연속된 블록 묶음을 하나로 표현 → 디스크 단편화 최소화

    B-Tree

    이거 표로 정리해줘

  - 답변

    ## 파일 시스템 종류 비교

    요청하신 파일 시스템 종류를 표로 정리했습니다.

    | 특징            | **FAT (File Allocation Table)**                                                                       | **NTFS (New Technology File System)** | **EXT4 (Fourth Extended File System)**          |
    | --------------- | ----------------------------------------------------------------------------------------------------- | ------------------------------------- | ----------------------------------------------- |
    | **주요 사용처** | 윈도우 초창기, USB, SD 카드, 카메라 등 다양한 기기                                                    | 윈도우 NT 이상 시스템                 | 현대 리눅스 시스템                              |
    | **버전/종류**   | FAT12, FAT16, FAT32                                                                                   | -                                     | -                                               |
    | **구조**        | 단순                                                                                                  | -                                     | Extent 구조 (연속된 블록 묶음), B-Tree          |
    | **저널링 지원** | O                                                                                                     | X                                     | O                                               |
    | **장점**        | 구조 단순, 다양한 기기 호환성 우수                                                                    | 파일 권한, 암호화, 압축 지원          | 16TB까지 파일 시스템 지원, 디스크 단편화 최소화 |
    | **단점**        | 단일 파일 최대 크기 4GB (정확히는 4GB - 1) 제한, Windows 기본 도구에서 32GB 이상 장치 FAT32 포맷 불가 | -                                     | -                                               |

  분석

  - `FAT 저널링 O` 이라는 잘못된 정보 전달 → **`저널링 X → 갑자기 전원이 끊기면 데이터 손상 가능성 있음`**
  - `NTFS 저널링 X` 이라는 잘못된 정보 전달 → **`저널링 O`**
  - 잘못된 정보를 바탕으로 표를 작성해줌

- Day 08 (Claude Sonnet 4)

  - 질문

    ## 람다 또는 클로저

    클로저는 람다계산식(Lambda Calculus) 구현체로, 이름 없는 함수(anonymous function)로 리터럴하게 작성 가능하다.

    클로저의 특징

    - 선언된 범위(scope)에서 접근 가능한 변수를 캡처해서 저장하고 닫힌다
    - Java(11이후), Kotlin 클로저는 캡처한 변수를 참조(reference)한다
    - 실행 시점의 바깥 변수 값을 캡처하여 계속 사용할 수 있다

    ```kotlin
    // 기본 람다 표현식
    val add: (Int, Int) -> Int = { x, y -> x + y }

    // 클로저 - 외부 변수 캡처
    fun createMultiplier(factor: Int): (Int) -> Int {
        return { number -> number * factor }  // factor를 캡처
    }

    val doubler = createMultiplier(2)
    println(doubler(5))  // 10

    // 고차함수와 함께 사용
    val numbers = listOf(1, 2, 3, 4, 5)
    val doubled = numbers.map { it * 2 }  // 람다를 map에 전달
    ```

    예시가 적절해?

  - 답변

    예시가 적절합니다! 클로저의 핵심 개념들을 잘 보여주고 있어요.

    **좋은 점들:**

    - 기본 람다 표현식부터 시작해서 단계적으로 설명
    - `createMultiplier` 예시가 클로저의 핵심인 "외부 변수 캡처"를 명확히 보여줌
    - 실용적인 고차함수 사용 예시까지 포함

    **더 명확하게 하려면 이런 예시도 추가할 수 있어요:**

    ```kotlin
    // 클로저가 변수의 현재 값을 캡처하는 것을 보여주는 예시
    fun createCounter(): () -> Int {
        var count = 0
        return { ++count }  // count 변수를 캡처하고 상태를 유지
    }

    val counter1 = createCounter()
    val counter2 = createCounter()

    println(counter1())  // 1
    println(counter1())  // 2
    println(counter2())  // 1 (독립적인 클로저)

    ```

    이 예시는 각 클로저가 독립적으로 변수를 캡처하고 상태를 유지한다는 점을 더 명확히 보여줍니다. 하지만 원래 예시만으로도 클로저의 기본 개념은 충분히 잘 설명되어 있어요.

  분석

  - Java(11이후)라는 잘못된 정보 전달 → Java 8 이후
  - “옳지 않은 부분 있어?”라고 물어봐야 버전이 다르다고 나옴. 그 전까지는 여전히 Java11 유지.
  - 개념이 아닌 다른 부분을 언급해서 그런 것 같다.

- Day 09 (Claude Sonnet 4)

  - 질문

    ## 교착 상태

    - 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태
    - 각 프로세스는 서로가 원하는 자원을 유지한 채 다른 프로세스이 자원을 얻기만을 기다림
    - 교착 상태가 발생하기 위한 4가지 필요 조건
      - 상호 배제: 주어진 시간 내에 하나의 프로세스만 자원을 독점
      - 점유 대기
      - 비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없다.
      - 환형 대기: A → B 자원 요구, B → A 자원 요구 ⇒ 서로가 서로의 자원을 요구
    - 해결 방법
      - **Dekker’s Algorithm**
      - 매우 드물게 발생 → 처리 비용이 더 커서 사용자가 작업을 종료하도록
        - ex) “응답 없음” 이라고 뜰 때

    교착상태의 필요 조건은 이 4가지가 맞지?

  - 답변

    네, 맞습니다! 교착상태가 발생하기 위한 4가지 필요조건이 정확합니다:

    1. **상호 배제(Mutual Exclusion)** - 한 번에 하나의 프로세스만 자원을 사용할 수 있음
    2. **점유 대기(Hold and Wait)** - 프로세스가 자원을 보유한 상태에서 다른 자원을 기다림
    3. **비선점(No Preemption)** - 다른 프로세스가 보유한 자원을 강제로 빼앗을 수 없음
    4. **환형 대기(Circular Wait)** - 프로세스들이 순환적으로 서로의 자원을 기다림

    이 4가지 조건이 **모두 동시에** 만족되어야 교착상태가 발생합니다. 따라서 교착상태를 예방하려면 이 중 하나라도 성립하지 않도록 하면 됩니다.

    참고로 Dekker's Algorithm은 교착상태 해결보다는 임계구역 문제 해결을 위한 알고리즘입니다. 교착상태 해결 방법으로는 예방(Prevention), 회피(Avoidance), 탐지 및 회복(Detection & Recovery), 무시(Ignore) 등이 있습니다.

  - Dekker’s Algorithm 이 교착상태의 해결 방법이라는 잘못된 정보 전달 → 은행원 알고리즘(Dekker’s Algorithm도 간접적으로 관련은 있음)
  - 해결 방법 부분말고 교착 상태의 필요 조건에 대해 물어봤는데, 해결 방법이 잘못되었다고 알려줌

### 최종 결론

- 어떤 모델은 표를 만드는데 오류를 찾지만, 찾지 못할 때도 있다.
- 직접적으로 해당 오류 부분을 언급하거나 오류 체크를 요청하면 오류를 잘 찾아낸다.
- 결론: 50프로의 성공 → 여전히 완벽하게 오류를 찾아내지는 못한다.
